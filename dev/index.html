<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SmallStrainPlastic Documentation · SmallStrainPlastic Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SmallStrainPlastic Documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>SmallStrainPlastic Documentation</a><ul class="internal"><li><a class="tocitem" href="#Plasticity-Model"><span>Plasticity Model</span></a></li><li><a class="tocitem" href="#State-of-Plasticity"><span>State of Plasticity</span></a></li><li><a class="tocitem" href="#Easier-Finding-of-Jacobians"><span>Easier Finding of Jacobians</span></a></li><li><a class="tocitem" href="#Return-Mapping-Alogrithm"><span>Return Mapping Alogrithm</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SmallStrainPlastic Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SmallStrainPlastic Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/samadritakarmakar/smallStrainPlastic.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SmallStrainPlastic-Documentation"><a class="docs-heading-anchor" href="#SmallStrainPlastic-Documentation">SmallStrainPlastic Documentation</a><a id="SmallStrainPlastic-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#SmallStrainPlastic-Documentation" title="Permalink"></a></h1><p>SmallStrainPlastic is a library that aims to simplify the addition of different plastic models. The usage may be for a material point to judge the behaviour of a plastic model or to in a finite element model to simulate the behaviour of a plastic material.</p><p>The assumptions made while developing the library are the following:</p><p>The flow rule for plastic strain is considered to be:</p><p>𝛆̇ᵖ = λ̇  Θ(𝛔, 𝐪)</p><p>The flow rule for internal variable is considered to be:</p><p>𝛂̇ = λ̇  𝐡(𝛔, 𝐪)</p><p>The stress is considered as:</p><p>𝛔 = ℂ:(𝛆 - 𝛆ᵖ)</p><p>The hardening variable is considered as:</p><p>𝐪 = - 𝓗(𝛂)</p><p>Special Unicode characters using eg: &quot;\bb<em>&quot;, &quot;\bf</em>&quot;, or &quot;\bsrc*&quot; are used to define functions. It is highly recommended such unicode characters are avoided when defining internal variables to avoid confusion.</p><h2 id="Plasticity-Model"><a class="docs-heading-anchor" href="#Plasticity-Model">Plasticity Model</a><a id="Plasticity-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Plasticity-Model" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SmallStrainPlastic.PlasticModel" href="#SmallStrainPlastic.PlasticModel"><code>SmallStrainPlastic.PlasticModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A plasticity new plasticity model can be defined by defining the following functions:</p><p>Yield Function:-</p><pre><code class="language-none">𝒇(σ_voigt::Array{Float64, 1}, q::Array{Float64, 1}, params::ModelParams)</code></pre><p>The partial of Yield Function with respect to stress, ∂𝒇/∂𝛔:-</p><pre><code class="language-none">∂𝒇_∂𝛔(σ_voigt::Array{Float64, 1}, q::Array{Float64, 1}, params::ModelParams)</code></pre><p>The partial of Yield Function with respect to hardening variable, ∂𝒇/∂𝐪:</p><pre><code class="language-none">∂𝒇_∂𝐪(σ_voigt::Array{Float64, 1}, q::Array{Float64, 1},  params::ModelParams)</code></pre><p>The function in the flow rule for the plastic strain, 𝛆̇ᵖ = λ̇  𝚯(𝛔, 𝐪) :-</p><pre><code class="language-none">𝚯(σ_voigt::Array{Float64, 1}, q::Array{Float64, 1}, params::ModelParams)</code></pre><p>The partial of plastic strain flow rule function with respect to stress, ∂𝚯/∂𝛔:-</p><pre><code class="language-none">∂𝚯_∂𝛔(σ_voigt::Array{Float64, 1}, q::Array{Float64, 1}, params::ModelParams)</code></pre><p>The partial of plastic strain flow rule function with respect to hardening, ∂𝚯/∂𝐪:-</p><pre><code class="language-none">∂𝚯_∂𝐪(σ_voigt::Array{Float64, 1}, q::Array{Float64, 1}, params::ModelParams)</code></pre><p>The function in the flow rule for the internal variable 𝛂̇ = λ̇  𝐡(𝛔, 𝐪):-</p><pre><code class="language-none">𝐡(σ_voigt::Array{Float64, 1}, q::Array{Float64, 1}, params::ModelParams)</code></pre><p>The partial of plastic strain flow rule function with respect to stress, ∂𝐡/∂𝛔:-</p><pre><code class="language-none">∂𝐡_∂𝛔(σ_voigt::Array{Float64, 1}, q::Array{Float64, 1}, params::ModelParams)</code></pre><p>The partial of plastic strain flow rule function with respect to hardening, ∂𝐡/∂𝐪:-</p><pre><code class="language-none">∂𝐡_∂𝐪(σ_voigt::Array{Float64, 1}, q::Array{Float64, 1},  params::ModelParams)</code></pre><p>If the evolution of the hardening variable 𝐪̇ is defined as 𝐪̇ = -𝓗(𝛂), then the function it is dependent on can be written as:-</p><pre><code class="language-none">𝓗(σ_voigt::Array{Float64, 1}, q::Array{Float64, 1}, α::Array{Float64, 1}, params::ModelParams)</code></pre><p>For ease of use, defining a function that saves the stiffness tensor is also made available :-</p><pre><code class="language-none">ℂ(σ_voigt::Array{Float64, 1}, q::Array{Float64, 1},  params::ModelParams)</code></pre><p>If the hardening variable 𝐪̇ is defined as 𝐪̇ = -𝓗(𝛂), then an equivalent to stiffness tensor defined as ℂ = ∂𝛔/∂𝛆ᵉ, we can defined as 𝔻 = -∂𝐪/∂𝛂 = ∂𝓗(𝛂)/∂𝐪 :-</p><pre><code class="language-none">𝔻(σ_voigt::Array{Float64, 1}, q::Array{Float64, 1},  params::ModelParams)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/samadritakarmakar/smallStrainPlastic.jl/blob/49c1d35ebb21d08112a590df131857d0b2c3c199/src/plasticity/plasticModel.jl#L1-L53">source</a></section></article><h2 id="State-of-Plasticity"><a class="docs-heading-anchor" href="#State-of-Plasticity">State of Plasticity</a><a id="State-of-Plasticity-1"></a><a class="docs-heading-anchor-permalink" href="#State-of-Plasticity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SmallStrainPlastic.State" href="#SmallStrainPlastic.State"><code>SmallStrainPlastic.State</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This structure saves the state of the material, meaning it&#39;s plastic strain and hardening variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/samadritakarmakar/smallStrainPlastic.jl/blob/49c1d35ebb21d08112a590df131857d0b2c3c199/src/plasticity/state.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SmallStrainPlastic.createStateDict" href="#SmallStrainPlastic.createStateDict"><code>SmallStrainPlastic.createStateDict</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function creates a Dictionary of type State to store the state of the material, meaning it&#39;s plastic strain and hardening variable.</p><pre><code class="language-none">stateDict = createStateDict()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/samadritakarmakar/smallStrainPlastic.jl/blob/49c1d35ebb21d08112a590df131857d0b2c3c199/src/plasticity/state.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SmallStrainPlastic.updateStateDict!" href="#SmallStrainPlastic.updateStateDict!"><code>SmallStrainPlastic.updateStateDict!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function updates the StateDict according to the passed data of ϵᵖ and α for a specific element number and an integration point within the given element.</p><pre><code class="language-none">updateStateDict!(ϵᵖ, α, stateDict, elementNo, integrationPt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/samadritakarmakar/smallStrainPlastic.jl/blob/49c1d35ebb21d08112a590df131857d0b2c3c199/src/plasticity/state.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SmallStrainPlastic.getState!" href="#SmallStrainPlastic.getState!"><code>SmallStrainPlastic.getState!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function gets the state of the material, meaning it&#39;s plastic strain and hardening variable. If they exist in the Dictionary for the given material/integration point in the given element, it updates the data with the available data in stateDict. If they don&#39;t exist, it just fills the state varibles with zeros.</p><pre><code class="language-none">getState!(ϵᵖ, α, stateDict, elementNo, integrationPt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/samadritakarmakar/smallStrainPlastic.jl/blob/49c1d35ebb21d08112a590df131857d0b2c3c199/src/plasticity/state.jl#L7-L14">source</a></section></article><h2 id="Easier-Finding-of-Jacobians"><a class="docs-heading-anchor" href="#Easier-Finding-of-Jacobians">Easier Finding of Jacobians</a><a id="Easier-Finding-of-Jacobians-1"></a><a class="docs-heading-anchor-permalink" href="#Easier-Finding-of-Jacobians" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SmallStrainPlastic.denseJacobian!" href="#SmallStrainPlastic.denseJacobian!"><code>SmallStrainPlastic.denseJacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>When working with plastic models it many times it becomes difficult to find the analytically jacobian of a vector function. With denseJacobian we try to make that easy to do. It uses finite difference to do this. Finite Differences are far from the best solution to find jacobians but are the easiest to implement. Hence this solution.</p><pre><code class="language-none">denseJacobian!(jacobian::Array{Float64,2}, f::Function, x::Array{Float64,1})</code></pre><p>Here &quot;jacobian&quot; must have row size equal to length of vector returned by Function &quot;f&quot; and column size equal to length of vector &quot;x&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/samadritakarmakar/smallStrainPlastic.jl/blob/49c1d35ebb21d08112a590df131857d0b2c3c199/src/tools/denseJacobian.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SmallStrainPlastic.denseJacobian" href="#SmallStrainPlastic.denseJacobian"><code>SmallStrainPlastic.denseJacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><p>denseJacobian is an easier to use version of denseJacobian!. This is less efficient than denseJacobian!. Hence whenever possible denseJacobian! must be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/samadritakarmakar/smallStrainPlastic.jl/blob/49c1d35ebb21d08112a590df131857d0b2c3c199/src/tools/denseJacobian.jl#L26-L28">source</a></section></article><h2 id="Return-Mapping-Alogrithm"><a class="docs-heading-anchor" href="#Return-Mapping-Alogrithm">Return Mapping Alogrithm</a><a id="Return-Mapping-Alogrithm-1"></a><a class="docs-heading-anchor-permalink" href="#Return-Mapping-Alogrithm" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SmallStrainPlastic.returnMapping!" href="#SmallStrainPlastic.returnMapping!"><code>SmallStrainPlastic.returnMapping!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function is responsible for executing the return mapping algorithm. It does so by calculating the evolution of the plastic strain using the Closest Point Projection method. The following formulations are used</p><p>Here&#39;s an equation: <span>$d(\Delta\lambda) = \frac{f^k - \begin{bmatrix}\partial f^k/\partial \sigma &amp; \partial f^k/ \partial q\end{bmatrix}\begin{bmatrix}A\end{bmatrix}\begin{bmatrix} R \end{bmatrix}} {\begin{bmatrix}\partial f^k/\partial \sigma &amp; \partial f^k/ \partial q\end{bmatrix}\begin{bmatrix}A\end{bmatrix}\begin{bmatrix}\Theta \\ h \end{bmatrix}}$</span></p><p>where:</p><p><span>$\begin{bmatrix}R\end{bmatrix} = -\begin{bmatrix} \epsilon^p_{n+1} \\ \alpha_{n+1} \end{bmatrix} +\begin{bmatrix} \epsilon^p_{n} \\ \alpha_{n} \end{bmatrix} +\Delta\lambda\begin{bmatrix} \Theta(\sigma_{n+1}, q_{n+1}) \\ h(\sigma_{n+1}, q_{n+1}) \end{bmatrix}$</span> <span>$\begin{bmatrix}A\end{bmatrix}^{-1} = \begin{bmatrix} \bm{C}^{-1} + \Delta\lambda \frac{\partial \Theta}{\partial\sigma_{n+1}} &amp; \Delta\lambda \frac{\partial \Theta}{\partial q_{n+1}} \\ \Delta\lambda \frac{\partial h}{\partial\sigma_{n+1}} &amp; \bm{D}^{-1} + \Delta\lambda \frac{\partial h}{\partial q_{n+1}} \end{bmatrix}$</span></p><p>The Strain 𝛆ᵖ and the internal variable 𝛂 are updated as,</p><p><span>$\begin{bmatrix}\Delta \epsilon^p \\ \Delta \alpha \end{bmatrix} = \begin{bmatrix}\bm{C}^{-1} &amp; 0 \\ 0 &amp; \bm{D}^{-1} \end{bmatrix} \begin{bmatrix}A\end{bmatrix} \begin{bmatrix}\Theta \\ h \end{bmatrix} d(\Delta\lambda)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/samadritakarmakar/smallStrainPlastic.jl/blob/49c1d35ebb21d08112a590df131857d0b2c3c199/src/plasticity/returnMapping.jl#L80-L108">source</a></section></article><h3 id="An-example-using-J2-Plastic-Model"><a class="docs-heading-anchor" href="#An-example-using-J2-Plastic-Model">An example using J2 Plastic Model</a><a id="An-example-using-J2-Plastic-Model-1"></a><a class="docs-heading-anchor-permalink" href="#An-example-using-J2-Plastic-Model" title="Permalink"></a></h3><pre><code class="language-none">using SmallStrainPlastic, Plots
function testJ2()
	σ_y = 200.0
	E = 200e3
	ν = 0.3
	plasticVars =SmallStrainPlastic.initPlasticVars(SmallStrainPlastic.j2Model)
  	plasticVars.C = SmallStrainPlastic.createVoigtElasticTensor(E, ν)
	params_J2 = SmallStrainPlastic.initParams_j2(σ_y, 0.0)
	𝒑Array::Array{Float64, 1} = zeros(0)
	𝒒Array::Array{Float64, 1} = zeros(0)
	𝒆Array::Array{Float64, 1} = zeros(0)
	𝒆ₛArray::Array{Float64, 1} = zeros(0)
	for i ∈ 1:82
    		if (i&lt;=20)
        		plasticVars.ϵ[1] += 1e-4
    		elseif (i&gt;20 &amp;&amp; i&lt;=55)
        		plasticVars.ϵ[1] -= 1e-4
    		else
       		 	plasticVars.ϵ[1] += 1e-4
    		end
    		SmallStrainPlastic.checkPlasticState!(plasticVars, SmallStrainPlastic.j2Model, params_J2, 1, 1)
   		 𝒑, 𝒒 = SmallStrainPlastic.get_𝒑_𝒒(plasticVars.σ_voigt)
    		push!(𝒑Array, 𝒑)
    		push!(𝒒Array, 𝒒)
    		𝒆, 𝒆ₛ = get_𝒆_𝒆ₛ(plasticVars.ϵ)
    		push!(𝒆Array, 𝒆)
   		push!(𝒆ₛArray, 𝒆ₛ) 
	end
	plot(𝒆Array, 𝒒Array, legend=false)#, seriestype = :scatter)
end</code></pre><p>You should get a plot like this: <img src="PerfectPlasticity.png" alt="Plot Perfect Plasticity"/></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 29 December 2020 14:00">Tuesday 29 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
