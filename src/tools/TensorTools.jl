function createVoigtElasticTensor(E::Float64, Î½::Float64)::Array{Float64, 2}
    c::Float64 = E/((1+Î½)*(1-2*Î½))
    C::Array{Float64, 2} = zeros(6,6)
    C = [1-Î½ Î½ Î½ 0 0 0;
         Î½ 1-Î½ Î½ 0 0 0;
         Î½ Î½ 1-Î½ 0 0 0;
         0 0 0 (1-2*Î½)/2 0 0;
         0 0 0 0 (1-2*Î½)/2 0;
         0 0 0 0 0 (1-2*Î½)/2]
    C = c*C
    return C
end

"""From the book The Finite Element Method for Solid and Structural Mechanics,
Seventh Edition, O.C. Zienkiewicz, R.L. Taylor, D.D. Fox.
Páµ€ = [2.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  2.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0  1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0  1.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0]
 and,
 Ïƒ_voigt = Páµ€*Ïƒ_Mandel
 Ïµ_Mandel = P*Ïµ_voigt
"""
function get_Páµ€()
    Páµ€= zeros(6,9)
    Páµ€[1:3,1:3]= Array{Float64, 2}(I, 3, 3)
    col::Int64 = 4
    for row âˆˆ 4:6
        Páµ€[row,col:col+1] = 0.5*ones(2)
        col +=2
    end
    return Páµ€
end

"""From the book The Finite Element Method for Solid and Structural Mechanics,
Seventh Edition, O.C. Zienkiewicz, R.L. Taylor, D.D. Fox.
Páµ€ = [2.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  2.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0  1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0  1.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0]
 and,
 Ïƒ_voigt = Páµ€*Ïƒ_Mandel
 Ïµ_Mandel = P*Ïµ_voigt
"""
function get_P()
    return get_Páµ€()'
end

"""Get the tensor map used by SmallStrain Plastic Library

    tensorMap = SmallStrainPlastic.getTensorMapping()
"""
function getTensorMapping()::Dict{Int64, Int64}
    mapDict::Dict{Int64, Int64} = Dict{Int64, Int64}()
    mapDict[11] = 1
    mapDict[22] = 2
    mapDict[33] = 3
    mapDict[12] = 4
    mapDict[21] = 5
    mapDict[23] = 6
    mapDict[32] = 7
    mapDict[31] = 8
    mapDict[13] = 9
    return mapDict
end

"""Use the tensor map generated by SmallStrain Plastic Library

    ij = SmallStrainPlastic.getVoigtIndex(tensorMap, i, j)
"""
function getVoigtIndex(mapDict::Dict{Int64, Int64}, i::Int64, j::Int64)::Int64
    return mapDict[10*i+j]
end

"""Double contraction of two tensors using Mandel Notation as per "The Finite Element Method for Solid and Structural Mechanics,
Seventh Edition, O.C. Zienkiewicz, R.L. Taylor, D.D. Fox."

    result = doubleContract(Array1, Array2)
"""
function doubleContract(Array1::Array{T,1}, Array2::Array{T,1}) where T
    mapDict = getTensorMapping()
    if (size(Array1, 2) ==1)
        Array1 = Array1' #Transposes Array1 so that the use Array1[ij,mn] is still valid
    end
    rows = size(Array1, 1)
    cols = size(Array2, 2)
    @assert ((rows == 1 || rows == 9) && (cols ==1 || cols ==9)) "Array1 or Array2
    must either have a size of 9x1 or 9x9 representing a second order tensor or a
    4th order tensor respectively."
    ijLength = rows > 1 ? 3 : 1
    klLength = cols > 1 ? 3 : 1
    #R_{ijkl} = C_{ijmn}D_{opkl}
    R = zeros(T, rows, cols)
    for k âˆˆ 1:klLength
        for l âˆˆ 1:klLength
            kl = getVoigtIndex(mapDict, k,l)
            for i âˆˆ 1:ijLength
                for j âˆˆ 1:ijLength
                    ij = getVoigtIndex(mapDict, i,j)
                    for m âˆˆ 1:3
                        for n âˆˆ 1:3
                            mn = getVoigtIndex(mapDict, m,n)
                            R[ij,kl] += Array1[ij,mn]*Array2[mn,kl]
                        end
                    end
                end
            end
        end
    end
    return R
end
"""2nd Order tensor Norm save in array as per  mandel notation given in "The Finite Element Method for Solid and Structural Mechanics,
Seventh Edition, O.C. Zienkiewicz, R.L. Taylor, D.D. Fox."

    frobeniusNorm_p2(array)
"""
function frobeniusNorm_p2(array::Array{T,1}) where T
    fN = doubleContract(array, array)
    return sqrt(fN[1])
end

"""Trace of second order mandel notation tensor.

    arrayTrace = trace(array)
"""
function trace(array::Array{T,1}) where T
    m = zeros(9)
    m[1:3] = ones(3)
    return m'*array
end

"""Generates 2nd Order Identity tensor in mandel notation

    Order2I = getOrder2Identity()
"""
function getOrder2Identity()
    Î´(i, j) = i == j ? 1.0 : 0.0
    mapDict = getTensorMapping()
    I = zeros(9)
    for i âˆˆ 1:3
        for j âˆˆ 1:3
            ij = getVoigtIndex(mapDict, i, j)
            I[ij] += Î´(i,j)
        end
    end
    return I
end


"""Generates 4th Order Identity tensor in mandel notation

    Order4I = getOrder4Identity()
"""
function getOrder4Identity()
    Î´(i, j) = i == j ? 1.0 : 0.0
    mapDict = getTensorMapping()
    I = zeros(9,9)
    for k âˆˆ 1:3
        for l âˆˆ 1:3
            kl = getVoigtIndex(mapDict, k, l)
            for i âˆˆ 1:3
                for j âˆˆ 1:3
                    ij = getVoigtIndex(mapDict, i, j)
                    I[ij,kl] += Î´(i,j)*Î´(k,l)
                end
            end
        end
    end
    return I
end


"""Generates 4th Order Symmetric Identity tensor in mandel notation

    Order4ISym = getOrder4SymIdentity()
"""
function getOrder4SymIdentity()
    Î´(i, j) = i == j ? 1.0 : 0.0
    mapDict = getTensorMapping()
    I = zeros(9,9)
    for k âˆˆ 1:3
        for l âˆˆ 1:3
            kl = getVoigtIndex(mapDict, k, l)
            for i âˆˆ 1:3
                for j âˆˆ 1:3
                    ij = getVoigtIndex(mapDict, i, j)
                    I[ij,kl] +=0.5*(Î´(i,k)*Î´(j,l)+Î´(i,l)*Î´(j,k))
                end
            end
        end
    end
    return I
end

"""Generates Elastic 4th order Tensor as per Mandel Notation mentioned in "The Finite Element Method for Solid and Structural Mechanics,
Seventh Edition, O.C. Zienkiewicz, R.L. Taylor, D.D. Fox."

    C_mandel = getMandelElasticTensor(200e3, 0.3)
"""
function getMandelElasticTensor(E::Float64, Î½::Float64)::Array{Float64, 2}
    Î» = Î½*E/((1+Î½)*(1-2*Î½))
    Î¼ = E/(2*(1+Î½))
    I4 = getOrder4Identity()
    #I4Sym = getOrder4SymIdentity()
    #return Î»*I4 .+ 2*Î¼*I4Sym
    return Î»*I4 .+ 2*Î¼*Array{Float64,2}(I, 9,9)
end

"""Transform mandel notation 2nd or 4th order tensor to voigt notation

    arrayVoigt = mandel2voigt(arrayMandel)
"""
function mandel2voigt(array::Array{T,1}) where T
    rowSize = size(array, 1)
    colSize = size(array, 2)
    @assert (rowSize==9 || colSize ==9) "mandel2voigt function can only be used for arrays of 9x1 or 9x9 size."
    rowLength = rowSize > 1 ? 3 : 1
    colLength = colSize > 1 ? 3 : 1
    Páµ€ = get_Páµ€()
    if (rowLength ==3 && colLength ==3)
        P = get_P()
        arrayVoigt = Páµ€*array*P
    else
        arrayVoigt = Páµ€*array
    end
    return arrayVoigt
end


"""Transform mandel notation stress to voigt notation or engineering stress

    arrayVoigt = getVoigtEngineeringStress(arrayMandel)
"""

function getVoigtEngineeringStress(Ïƒ_mandel::Array{T,1}) where T
    return Páµ€*Ïƒ_mandel
end

"""Transform voigt notation strain to  mandel continuum strain

    strainEngineering = mandel2voigt(arrayMandel)
"""
function getContinuumMandelStrain(Ïµ_MandelContinuum::Array{T,1}) where T
    return get_P()*Ïµ_MandelContinuum
end

function ProjectionTensor4(i::Int64, j::Int64, k::Int64, l::Int64)
    return (i == k ? 1.0 : 0.0)*(j == l ? 1.0 : 0.0)-1.0/3.0*(i == j ? 1.0 : 0.0)*(k == l ? 1.0 : 0.0)
end


function getProjectionTensor()
    mapDict = getTensorMapping()
    P = zeros(9,9)
    for k âˆˆ 1:3
      for l âˆˆ 1:3
          kl = getVoigtIndex(mapDict, k, l)
          for i âˆˆ 1:3
              for j âˆˆ 1:3
                  ij = getVoigtIndex(mapDict, i, j)
                  P[ij,kl] += ProjectionTensor4(i,j,k,l)
              end
          end
      end
  end
  return P
end

function get_Ïƒâ‚˜_ğ¬_mandel(Ïƒ_mandel::Array{T,1}) where T
    Ïƒâ‚˜::Float64 = sum(Ïƒ_mandel[1:3])
    #Deviatoric Stress
    Ïƒ_mandel -= 1.0/3.0*Ïƒâ‚˜*[1, 1, 1, 0, 0, 0, 0, 0, 0]
    ğ¬::Float64 = sqrt(3.0/2.0)*norm(Ïƒ_mandel)
    return Ïƒâ‚˜, ğ¬
end

function get_Ïµâ‚˜_ğ’†_mandel(Ïµ::Array{T,1}) where T
    Ïµâ‚˜::Float64 = sum(Ïµ[1:3])
    #Deviatoric Stress
    Ïµ -= 1.0/3.0*Ïµâ‚˜*[1, 1, 1, 0, 0, 0, 0, 0, 0]
    ğ’†::Float64 = sqrt(2.0/3.0)*norm(Ïµ)
    return Ïµâ‚˜, ğ’†
end
